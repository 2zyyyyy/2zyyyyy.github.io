{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hexo 问题记录","text":"本文主要目的是为了记录一下Hexo博客在使用过程中遇到过的问题，不定时更新。 20200107 hexo s 启动异常提示： 权限异常，解决方案： 命令行使用 sudo su 输入密码即可 20200107 hexo s启动异常： 端口占用，2种解决方法： 1、修改blog/_config.yml配置文件，新增 server: port: 5000 compress: true header: true 端口自定义即可(推荐) 2、命令修改本次启动使用端口 hexo server -p 9527 该方法仅对本次生效（不推荐）","link":"/2020/01/07/Hexo-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"Allure测试报告","text":"关于Allure2 + Pytest 组合生成的测试报告之前在公司组内也有做过分享，今天在blog这边在记录一下。 ​ 这边分为5个步骤，系统是macOS 10.12，这边不涉及环境配置比如Python、Java环境。 Step1: 安装依赖包 Pip install pytest Pip install allure Pip install allure-pytest Pip install allure-python-commons *macOS 不建议在brew环境安装第三方依赖，路径问题会导致各种异常。 Step2: 创建项目创建项目Demo report下面2个目录是分别存放2个格式的测试报告，默认pytest执行的用例结果放在xml下，是json格式的，需要命令转换成html格式的测试报告存放于xml下。 Step3: 设计用例原则 文件名以test_.py文件和_test.py 以test_开头的函数 以Test开头的类 以test_开头的方法 不支持类init初始化 可使用@pytest.fixture() testcase：校验登录接口返回 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# @File:test_02.py# @Author:2zyyyyy# @Time:2019年04月25日# @Explain:import allureimport jsonimport requestsimport pytestclass TestDemo: @staticmethod @allure.step('post 请求获取接口返回结果') def login(): url = 'http://192.168.0.000:8071/auth-service/login' headers = { 'Content-Type': 'application/json;charset=UTF-8' } payload = { &quot;userMobile&quot;: &quot;00000000000&quot;, &quot;systemId&quot;: &quot;000&quot;, &quot;terminalType&quot;: &quot;000&quot;, &quot;password&quot;: &quot;000000&quot; } response = requests.post(url=url, data=json.dumps(payload), headers=headers) result = response.json() result_dict = dict() result_dict['code'] = result['code'] result_dict['description'] = result['description'] return result_dict @allure.feature('登录功能') @allure.story('验证参数1') def test_01(self): &quot;&quot;&quot; 校验返回值是否为0000 &quot;&quot;&quot; with allure.step('获取请求返回的code值'): code = TestDemo.login() with allure.step('校验结果'): allure.attach('期望结果', '0000') allure.attach('实际结果', '0000') assert code['code'] == '0000' @allure.feature('登录功能') @allure.story('验证参数2') def test_02(self): &quot;&quot;&quot; 校验description是否为oh yeah,通过了 &quot;&quot;&quot; with allure.step('获取接口返回的description'): desc = TestDemo.login() with allure.step('校验结果'): allure.attach('期望结果', 'oh yeah,通过了') allure.attach('实际结果', 'oh yeah,通过了') assert desc['description'] == 'oh yeah,通过了'if __name__ == '__main__': pytest.main(['-s', '-q', '--alluredir', '/AllureDemo/report/xml(json格式结果存放路径)', 'test_02.py']) pytest.main(['allure', 'generate', '/AllureDemo/report/xml(json格式结果存放路径)', '-o', '/AllureDemo/report/html(html格式结果存放路径)']) 一个登录，2条用例。main里面的2个命令分别执行用例生成结果，最后将json结果转换HTML格式。 Step4: 生成Allure测试报告一共有2步 先生成json格式的在转换成HTML格式①在项目终端执行pytest –s –q –alluredir [XML格式文件夹]②第一步没有异常执行allure generate ./report/xml -o ./report/html –clean第一个目录是生成XML格式报告的路径 第二个目录是生成HTML报告的路径 Step5: 查看测试报告打开./report/html/index.html 选择浏览器打开 Pytest命令拓展 pytest -v [caseDir] # 运行指定目录中所有用例 pytest -v [caseDir]/test_01.py 运行指定文件中的所有用例 pytest -v [caseDir ]/test_02.py::TestDemo 运行指定文件中的测试类 pytest -v [caseDir ]/test_01.py::test_001 运行指定测试用例函数","link":"/2019/12/27/Allure%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"},{"title":"Android RecyclerView实现复杂列表布局","text":"​ 这次学习的内容是使用RecyclerView来实现一些较为复杂的布局，比如一个item： 最左边是一个imageview，中间部分为textView，textView下面又是一个textView，最右边为一个imageview。 1、首先在activity_main.xml中添加RecyclerView，随后正如之前所说的分别针对左中右新建3个XML布局文件命名为item_type_one、two、three.随后对其进行布局配置。2、新建一个adapter添加模拟数据。然后针对布局新建三个viewholder。随后新建一个抽象类TypeAbstractViewHolder，将三个viewholder用到的同一个方法封装起来调用,将三个viewHolder继承自抽象类。为了优雅。activity_main.xml: 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.example.tony.recyclerviewdemo.MainActivity&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycleView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/RelativeLayout&gt; item_type_one.xml: 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/avatar&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_marginLeft=&quot;20dp&quot; /&gt; &lt;TextView tools:text = &quot;月满轩尼诗&quot; android:id=&quot;@+id/name&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; item_type_two.xml: 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/avatar&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_marginLeft=&quot;20dp&quot; /&gt; &lt;LinearLayout android:layout_marginLeft=&quot;20dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;月满轩尼诗&quot; /&gt; &lt;TextView android:id=&quot;@+id/content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;5dp&quot; tools:text=&quot;月满轩尼诗是一部好电影吗？&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; item_type_three.xml: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:background=&quot;@android:color/white&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/avatar&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;20dp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/contentImage&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;60dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_marginLeft=&quot;20dp&quot; android:layout_marginRight=&quot;20dp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;20dp&quot; android:orientation=&quot;vertical&quot; android:layout_centerVertical=&quot;true&quot; android:layout_toRightOf=&quot;@+id/avatar&quot; android:layout_toEndOf=&quot;@+id/avatar&quot; android:layout_marginStart=&quot;20dp&quot;&gt; &lt;TextView android:id=&quot;@+id/name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; tools:text=&quot;月满轩尼诗&quot; /&gt; &lt;TextView android:id=&quot;@+id/content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;5dp&quot; tools:text=&quot;月满轩尼诗是一部好电影吗？&quot; /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 这边提一个小技巧，一般textview如果不设置文本内容的话是无法预览的，这里我们在属性中添加一个：tools:text=”abc”;这个时候abc就会在UI上面显示出来了，而且abc也不用加入string.xml. Java文件：MAinActivity.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.example.tony.recyclerviewdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private RecyclerView mRecyclerView; private DemoAdapter mAdapter; int colors[] = {android.R.color.holo_blue_light, android.R.color.holo_orange_light, android.R.color.holo_red_light}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mRecyclerView = (RecyclerView) findViewById(R.id.recycleView); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); mAdapter = new DemoAdapter(this); mRecyclerView.setAdapter(mAdapter); initData(); } private void initData() { List&lt;DataModel&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) { int type = (int) (Math.random() * 3 + 1); DataModel data = new DataModel(); data.avatarColor = colors[type - 1]; data.type = type; data.name = &quot;Name: &quot; + i; data.content = &quot;Content: &quot; + i; data.contentColor = colors[(type + 1) % 3]; list.add(data); } mAdapter.addList(list); mAdapter.notifyDataSetChanged(); }} DemoAdapter.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.tony.recyclerviewdemo;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/* * Created by Tony on 2016/12/3. */public class DemoAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;{ private LayoutInflater mLayoutInflater; private List&lt;DataModel&gt; mList = new ArrayList&lt;&gt;(); public DemoAdapter(Context context) { mLayoutInflater = LayoutInflater.from(context); } public void addList(List&lt;DataModel&gt; list) { mList.addAll(list); } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { switch (viewType) { case DataModel.TYPE_ONE: return new TypeOneViewHolder(mLayoutInflater.inflate(R.layout.item_type_one, parent, false)); case DataModel.TYPE_TWO: return new TypeTwoViewHolder(mLayoutInflater.inflate(R.layout.item_type_two, parent, false)); case DataModel.TYPE_THREE: return new TypeThreeViewHolder(mLayoutInflater.inflate(R.layout.item_type_three, parent, false)); } return null; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { ((TypeAbstractViewHolder) holder).bindHolder(mList.get(position)); } @Override public int getItemViewType(int position) { return mList.get(position).type; } @Override public int getItemCount() { return mList.size(); }} DataModel.class 123456789101112131415161718192021222324package com.example.tony.recyclerviewdemo;/** * Created by Tony on 2016/12/3. */public class DataModel { public static final int TYPE_ONE = 1; public static final int TYPE_TWO = 2; public static final int TYPE_THREE = 3; public int type; public int avatarColor; public String name; public String content; public int contentColor;} TypeAbstractViewHolder.class 12345678910111213141516package com.example.tony.recyclerviewdemo;import android.support.v7.widget.RecyclerView;import android.view.View;/** * Created by Tony on 2016/12/3. */public abstract class TypeAbstractViewHolder extends RecyclerView.ViewHolder{ public TypeAbstractViewHolder(View itemView) { super(itemView); } public abstract void bindHolder(DataModel model);} TypeOneViewHolder.class 1234567891011121314151617181920212223242526272829package com.example.tony.recyclerviewdemo;import android.view.View;import android.widget.ImageView;import android.widget.TextView;/** * Created by Tony on 2016/12/3. */public class TypeOneViewHolder extends TypeAbstractViewHolder { private ImageView avatar; private TextView name; public TypeOneViewHolder(View itemView) { super(itemView); avatar = (ImageView) itemView.findViewById(R.id.avatar); name = (TextView) itemView.findViewById(R.id.name); } //ViewHolder数据和外面数据绑定起来 @Override public void bindHolder(DataModel model) { avatar.setBackgroundResource(model.avatarColor); name.setText(model.name); }} TypeTwoViewHolder.class 12345678910111213141516171819202122232425262728293031323334package com.example.tony.recyclerviewdemo;import android.support.v7.widget.RecyclerView;import android.view.View;import android.widget.ImageView;import android.widget.TextView;/** * Created by Tony on 2016/12/3. */public class TypeTwoViewHolder extends TypeAbstractViewHolder { private ImageView avatar; private TextView name; private TextView content; public TypeTwoViewHolder(View itemView) { super(itemView); avatar = (ImageView) itemView.findViewById(R.id.avatar); name = (TextView) itemView.findViewById(R.id.name); content = (TextView) itemView.findViewById(R.id.content); } //ViewHolder数据和外面数据绑定起来 @Override public void bindHolder(DataModel model) { avatar.setBackgroundResource(model.avatarColor); name.setText(model.name); content.setText(model.content); }} TypeThreeViewHolder.class 12345678910111213141516171819202122232425262728293031323334353637package com.example.tony.recyclerviewdemo;import android.view.View;import android.widget.ImageView;import android.widget.TextView;/** * Created by Tony on 2016/12/3. */public class TypeThreeViewHolder extends TypeAbstractViewHolder { private ImageView avatar; private TextView name; private TextView content; private ImageView contentImage; public TypeThreeViewHolder(View itemView) { super(itemView); avatar = (ImageView) itemView.findViewById(R.id.avatar); contentImage = (ImageView) itemView.findViewById(R.id.contentImage); name = (TextView) itemView.findViewById(R.id.name); content = (TextView) itemView.findViewById(R.id.content); } //ViewHolder数据和外面数据绑定起来 @Override public void bindHolder(DataModel model) { avatar.setBackgroundResource(model.avatarColor); name.setText(model.name); contentImage.setBackgroundResource(model.contentColor); content.setText(model.content); }}","link":"/2019/12/26/Android-RecyclerView%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E5%88%97%E8%A1%A8%E5%B8%83%E5%B1%80/"},{"title":"Java 装饰者","text":"Java 当中的io流 今天记录下关于装饰者的学习一、处理流使用实例 1、本地新建一个users文本文档（刚入门没有使用IDE，都是在字符界面下进行编译和运行的，用文本文档进行代码的编写），内容如下： 张三 最强王者 850点 李四 超凡大师 700点 赵武 璀璨砖石 85点 王八 最强青铜 0点 刘六 不屈白银 25点 孙九 荣耀黄金 35点 //随便写的哈哈哈; //目的就是使用节点流来读取文件（单位：行）； 2、新建Test.java文件（.txt改一下后缀名即可，看不到的同学记得文件夹选项中点了显示已知文件和文件夹后缀名的选项；）下面贴代码： `//导入类java.io.*;12345678910111213141516171819202122232425262728293031class Test{ public static void main(String args []){ FileReader filereader = null; BufferedReader bufferedreader = null; try{ filereader = new FileReader(&quot;e:/eclipse/src/2016.02.25/users.txt&quot;); bufferedreader = new BufferedReader(filereader); String line = null; while(true){ line = bufferedreader.readLine(); if(line == null){ break; } System.out.println(line); } } catch(Exception e){ System.out.println(e); } finally{ try{ filereader.close(); bufferedreader.close(); } catch(Exception e){ System.out.println(e); } } }}` 3、编译运行 ==》win+R -- cmd -- 文件件路径输进去 -- javac *.java -- java Test 结果就是![运行结果](http://img.blog.csdn.net/20160302145715612)二：“装饰者”模式 1、举个Mars老师的例子吧 就是有一个工人的类 下面又分为各种工人比如说（水管工 木匠工 等等） 然后工人们又分为有A 公司的，B公司的，C公司的一次类推，如果每个工人都要写一个类的话，我们假设有N个工种，有M个公司，那么我们需要新建的class的个数就是：M*N个 这点很明显不符合计算机语言的做法，编程就是去繁化简，争取消灭所有的重复性的代码。因此就需要用到“装饰者”模式了。 2、新建一个接口名为 Aworker： Worker{1234567891011121314151617181920212223242526272829303132333435363738394041 public void doSomeWorker();} 新建水管工、木匠工、A公司、B公司类 //水管工 class Plumber implements Worker{ public void doSomeWorker(){ System.out.println(&quot;修水管！！！&quot;); }} //木匠工 class Carpenter implements Worker{ public void doSomeWorker(){ System.out.println(&quot;修门窗！！！&quot;); }} //A公司 class Aworker implements Worker{ private Worker worker; public Aworker(Worker worker){ this.worker = worker; } public void doSomeWorker(){ System.out.println(&quot;你好&quot;); worker.doSomeWorker(); }} //B公司 class Bworker implements Worker{ private Worker worker; public Bworker(Worker worker){ this.worker = worker; } public void doSomeWorker(){ System.out.println(&quot;我要带鞋套@@@@&quot;); worker.doSomeWorker(); }} 最后新建一个主函数来运行程序​ Test01{123456789101112 public static void main(String args []){ //生成一个A公司水管工的对象 Plumber plumber = new Plumber(); Aworker aworker1 = new Aworker(plumber); aworker1.doSomeWorker(); //生成一个B公司的木匠工对象 Carpenter carpenter = new Carpenter(); Bworker bworker1 = new Bworker(carpenter); bworker1.doSomeWorker(); }} 运行结果：![运行结果](http://img.blog.csdn.net/20160302151838939)三、节点流与处理流之间的关系 FileReader在（被装饰者）就是节点流，是真正读取数据的（单位：字符） 而处理流（装饰者）就是用来 给节点流添加功能的 ，使得前者可以一行一行的读取数据（BufferedReader）.","link":"/2019/12/26/Java-%E8%A3%85%E9%A5%B0%E8%80%85/"},{"title":"Jenkins(Win)构建失败,提示：xx不是内部或外部命令 也不是可运行程序或批处理文件","text":"最近在Windows上面玩Jenkins，创建demo项目之后想让他执行Python -m 命令，提示我该命令不是内部或外部命令 也不是可运行程序或批处理文件， 但是win+R下面运行又是正常的，查询了一下其他博主发现是环境变量没有配置导致的问题。下面就简单介绍一下如果遇到这个问题应该如何解决吧。 Step1:Jenkins首页-点击[构建执行状态] ###Step2: 找到右上角的[设置]按钮，点击 Step3：​ 跳转到设置页面： 新增一个[path]环境变量，值有2部分组成：1是Python文件夹 2是文件夹下Scripts目录,中间分号隔开，点击保存。 Step5:重新构建项目，查看控制台输出","link":"/2019/12/30/Jenkins-Windows-%E6%9E%84%E5%BB%BA%E5%A4%B1%E8%B4%A5-%E6%8F%90%E7%A4%BA-pytest-%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4-%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"},{"title":"Java-图书管理系统","text":"模拟借书系统，任务要求： 感觉自己的写出来的代码不够简洁，参考了其他的案例写了一个，效果如下：结构：运行异常1：运行异常2：运行异常3：正常运行：1、名称查询2、序号查询：Book.java: 123456789101112package com.tony;/* * 图书租赁系统 */public class Book { public String bookName; public int bookId; public Book(String bookName, int bookId){ this.bookName = bookName; this.bookId = bookId; } } 自定义异常类MyException.java: 12345678910package com.tony;/* * 自定义异常类 */public class MyException extends Exception{ //有参构造方法 public MyException(String message) { super(message); };} BorrowBook.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.tony;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Scanner;/* * 主程序 */public class BorrowBook { Book book [] = {new Book(&quot;高等数学&quot;, 1), new Book(&quot;大学英语&quot;, 2), new Book(&quot;Android&quot;, 3), new Book(&quot;会计基础&quot;, 4)}; public List&lt;Book&gt; listBooks; //无参构造方法 public BorrowBook() { this.listBooks = new ArrayList&lt;Book&gt;(); } public void addBook(){ listBooks.addAll(Arrays.asList(book)); } public void systemOut() { System.out.println(&quot;*******欢迎使用借书系统*******&quot;); System.out.println(&quot;*-*-*-*图书一览表：*-*-*-*&quot;); System.out.println(&quot; 书名&quot; + &quot;\\t\\t&quot; + &quot;序号&quot;); for(Book book:listBooks) { System.out.println(book.bookName + &quot;\\t\\t &quot; +book.bookId); } } private Scanner scanner = new Scanner(System.in); public static void main(String[] args) { BorrowBook borrowBook = new BorrowBook(); borrowBook.addBook(); borrowBook.systemOut(); while(true) { System.out.println(&quot;输入命令：1-按照名称查找图书;2-按照序号查找图书&quot;); switch (borrowBook.scanf()) { case 1://根据用户不同的输入内容执行 try { System.out.println(&quot;书籍：&quot; + borrowBook.findByName()); break; } catch (Exception e) { System.out.println(e.getMessage()); continue; } case 2: try { System.out.println(&quot;书籍：&quot; + borrowBook.findById()); break; } catch (Exception e) { System.out.println(e.getMessage()); continue; } default: System.out.println(&quot;命令错误，请重试.&quot;); continue; } break; } borrowBook.scanner.close(); } public String findByName() throws MyException{ System.out.println(&quot;*****请输入书籍的名称--&gt;&quot;); String name = scanner.next(); for (Book books : book) { if (name.equals(books.bookName)) { return books.bookName + &quot;\\t序号：&quot; +books.bookId; } } throw new MyException(&quot;名称错误，请重试.&quot;); } public String findById() throws MyException { System.out.println(&quot;*****请输入书籍的序号--&gt;&quot;); int in = scanner.nextInt(); for (int i = 0; i &lt; book.length; i++) { if (in == (i + 1)) { return book[i].bookName + &quot;\\t序号：&quot; + (i+1); } } throw new MyException(&quot;下标越界，请重试.&quot;); } public int scanf() { try { int in = scanner.nextInt(); return in; } catch(Exception e) { scanner = new Scanner(System.in); return -1; } }}","link":"/2019/12/26/Java-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"title":"Win10 远程连接Ubuntu错误(xrdp_mm_process_login_response:login failed)","text":"最近看到阿里云服务器优惠活动，最便宜的一年只需要￥89， 于是买了一个打算折腾一下，ssh连接上去之后，用win自带的远程连接登录查看可视化界面时，却总是提示失败 baidu、Google查了好久最后才意识到是不是键盘大小写的问题(阿里云服务器在设置密码的时候有包含大写字母)，修改成小写的之后就可以登录成功了。 后面有时间整理一下从购买服务器到SSH、RDP连接的一个流程。","link":"/2020/01/10/Win10-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5Ubuntu%E9%94%99%E8%AF%AF-xrdp/"},{"title":"我的第一篇Hexo博客","text":"原CSDN博客迁移说明https://blog.csdn.net/qq_31568297 这是在CSDN上的博客地址之前由于账户异常原因无法登录，现将迁移至Hexo目前该网站内容暂未做填充，内容会慢慢迁移过来，平时工作学习生活也将在这里记录","link":"/2019/12/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87hexo%E5%8D%9A%E5%AE%A2/"},{"title":"数据平台基础记录","text":"1、基本概念ETL(Extraction-Transformation-Loading) 数据抽取、转换和加载 ODS —— 操作性数据 DW —— 数据仓库 DM —— 数据集市 2、常用查询模糊查询表名 1show tables like '*name*' 查看表结构信息 1desc formatted 表名 3、日活数据统计3.1、基础数据新增用户 / 活跃用户 / 启动/访问次数 / 人均使用时长 检查数据发现当用户未登录状态时，写入的user_event.user_id为空 统计结果时未作区分 20190816当天数据都是未登录状态下产生的 统计结果新增和活跃用户均为：1 查询当日活跃用户数量 「表名」-「user_page」 1SELECT count(*) as total FROM (SELECT count(*) FROM datacenter.user_event where created_ymd = '20190819' GROUP BY user_id) a ; 统计当日页面停留时长 1️⃣规则：有A、B两个页面 统计页面停留时长 A页面停留时长=B.开始时间 - A.开始时间 B页面停留时长=B.end_time - b.start_time – 计算人均使用时长 – 时间不允许就用了比较麻烦的办法 一共三条SQL – ①先查询出当日所有活跃用户数 ②在查询出当日生成的所有trackID③计算每个trackID的时长（因为最后一条数据是需要end_time-start_time 所以单独计算）所有trackID相加为当日用户在线时长 – ① 统计当日活跃用户数 1SELECT COUNT(*) AS '当日活跃用户数' FROM (SELECT * FROM datacenter.user_page where created_ymd = '20190819' GROUP BY track_id) a; – ②查询当日所有trackID 1SELECT track_id FROM datacenter.user_page WHERE created_ymd = '20190922' GROUP BY track_id; # ③计算某个trackid的时长（2结果相加为当前trackID时长） 1234567891011121314151617181920212223242526272829303132333435363738SELECT sum( ( UNIX_TIMESTAMP( e.start_time ) - UNIX_TIMESTAMP( b.start_time ) ) ) AS '当前trackID时长', ( SELECT ( UNIX_TIMESTAMP( end_time ) - UNIX_TIMESTAMP( ( start_time ) ) ) AS '最后一条时长' FROM datacenter.user_page WHERE track_id = '135A6B1B-E35A-4CA4-953E-E670F6339AE3' ORDER BY start_time DESC LIMIT 1 ) AS '最后一条的时长' FROM ( SELECT a.start_time, ( @i := @i + 1 ) AS ord_num FROM user_page a, ( SELECT @i := 1 ) d WHERE a.track_id = '135A6B1B-E35A-4CA4-953E-E670F6339AE3' ORDER BY ​ a.start_time ​ ) b INNER JOIN ( ​ SELECT ​ a.start_time, ​ ( @j := @j + 1 ) AS ord_num ​ FROM ​ user_page a, ​ ( SELECT @j := 0 ) c WHERE ​ a.track_id = '135A6B1B-E35A-4CA4-953E-E670F6339AE3' ​ ORDER BY ​ a.start_time ) e ON b.ord_num = e.ord_num;","link":"/2020/01/07/%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E5%9F%BA%E7%A1%80%E8%AE%B0%E5%BD%95/"},{"title":"本地图片测试","text":"测试图片显示本地图片显示测试 1、方式有多种 我采用的是引用本地绝对路径 当然你也可以引用相对路径或者标签插件2、无须设置_config.yml中的post_asset_folder 默认为true 默认为false3、文章中图片使用！[](图片路径)如果是缩略图的话需要在icarus中的_config.yml.thumbnail设置为true,随后在文章的头部新增该标签，放入图片路径。thumbnail: /images/***.jpg","link":"/2019/12/25/%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/"},{"title":"自动化测试发送邮件异常","text":"​ 今天在学习发送邮件的时候遇到了几个问题，这边一是记录一下 二是给同样遇到问题的同学解惑 1、这个问题我发生的原因是163邮箱 SMTP协议未开启，如果已开启还是报这个错误尝试重新开启一次。开启之后是设置变量也好还是input密码记住不能用163邮箱的登录密码，而是需要使用设置的客户端授权密码。以上针对我出现的这个问题得到了解决。2、看廖雪峰的简单邮件实例发现自己运行后报554，官方解释就是被屏蔽了。 1234567891011121314151617181920from email.mime.text import MIMETextimport smtplibfrom email.header import Headermsg = MIMEText('真的不知道是什么原因', 'plain', 'utf-8')# 输入Email地址和口令:from_addr = 'xxx@163.com'password = '客户端授权密码'# 输入收件人信息:to_addr = 'xxx@qq.com'# 输入SMTP服务器地址:smtp_server = 'smtp.163.com'server = smtplib.SMTP(smtp_server, 25) # SMTP协议默认端口是25server.set_debuglevel(1) # 打印出和SMTP服务器交互的所有信息server.login(from_addr, password)server.sendmail(from_addr, [to_addr], msg.as_string())server.quit()print('success') 这样的163–&gt;qq 邮箱的（别的我没有试过）是不会成功的，一直报554的错误。我网上找了几个办法好像都行不通。后来我仔细琢磨了一下屏蔽原因会不会是右键内容太过单调而导致的呢。于是我新增了几个属性 123msg['Subject'] = Header('放假通知', 'utf-8')msg['From'] = 'xxx@163.com'msg['To'] = &quot;xxx@qq.com&quot; 运行成功。","link":"/2019/12/25/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%BC%82%E5%B8%B8-554/"},{"title":"Python批量写入数据到MySQL","text":"​ 之前在工作中，遇到一个大批量数据需要写到MySQL数据库中的工作，当时就用Python简单实现了一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465'''批量将Excel数据写入MySQL'''import pymysqlimport xlrddef mysql_link(db_name): ''' 连接数据库 guest:数据库名称 return:db ''' try: db = pymysql.connect(host='192.168.0.*', user='username', passwd='password', db=db_name, charset='utf8mb4') return db except ConnectionError as e: print(\"数据库连接异常!\" + str(e))def open_excel(excel_file): ''' 读取Excel函数 excel_file:表格文件路径 return：book ''' try: book = xlrd.open_workbook(excel_file) # 同一目录下 return book except Exception as e: print(str(e))def store_to(db_name, table_name, file_url): ''' 执行插入操作 db_name（数据库名称） table_name(表名称） excel_file（excel文件名，把文件与py文件放在同一目录下） ''' db = mysql_link(db_name) # 打开数据库连接 cursor = db.cursor() # 使用 cursor() 方法创建一个游标对象 cursor book = open_excel(file_url) # 打开excel文件 sheets = book.sheet_names() # 获取所有表名 for sheet in sheets: sh = book.sheet_by_name(sheet) # 打开每一张表 row_nuw = sh.nrows print(row_nuw - 1) listdata = [] # 定义列表原来存放数据 for i in range(1, row_nuw): # 表格首行title对应插入对应表的字段名 row_data = sh.row_values(i) # 按行获取Excel的值 listdata.append(row_data) # 将数据暂存在list print(listdata) sql = \"INSERT INTO \" + table_name + \"(tracking_name, tracking_no, create_date, sort_num, del_flag) \" \\ \"VALUES (%s, %s, %s, %s, %s)\" cursor.executemany(sql, listdata) # 执行SQL语句 db.commit() listdata.clear() print('插入成功！' + '共计' + str(row_nuw - 1) + '条数据!') cursor.close() db.close()if __name__ == '__main__': store_to('cccivaoperate', 't_tracking', '快递.xlsx')","link":"/2020/03/22/Python%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0MySQL/"},{"title":"Python爬取知乎图片","text":"​ 作为一名测试人员，电脑上各种各样的测试图片数据是必不可少的，那么如何去获取这些图片资源呢 ​ 获取数据的方案有很多种，作为测试员就要利用好Python的爬虫方法来爬取知乎回答内的所有图片资源，用的是Selenium 和 Python的BeautifulSoup等相关库，就是访问对应的问答URL地址，通过Selenium操作页面滚动，然后把页面上的所有图片路径爬取进行转码和存储，最后将本地存储的图片路径批量下载保存到本地文件夹。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from bs4 import BeautifulSoupfrom selenium import webdriverimport timeimport urllib.requestimport html.parserimport sslssl._create_default_https_context = ssl._create_unverified_contextdef main(): # ***************** 调用浏览器打开网址 ******************************* driver = webdriver.Safari() # URL driver.get('https://www.zhihu.com/question/292901966/answer/800705040') # 01新垣结衣 driver.get(\"https://www.zhihu.com/question/35931586\") # 02你的日常搭配是什么样子？ driver.get(\"https://www.zhihu.com/question/61235373\") # 03女生腿好看胸平是一种什么体验？ driver.get(\"https://www.zhihu.com/question/28481779\") # 04腿长是一种什么体验？ driver.get(\"https://www.zhihu.com/question/19671417\") # 05拍照时怎样摆姿势好看？ driver.get(\"https://www.zhihu.com/question/20196263\") # 06女性胸部过大会有哪些困扰与不便？ driver.get(\"https://www.zhihu.com/question/46458423\") # 07短发女孩要怎么拍照才性感？ driver.get(\"https://www.zhihu.com/question/26037846\") # 08身材好是一种怎样的体验？ driver.get(\"https://www.zhihu.com/question/333026642/answer/780949078\") # 09 def execute_times(times): # ***************** 滚动界面,点击更多按钮 *************************** for n in range(times): driver.execute_script('window.scrollTo(0, document.body.scrollHeight);') # 滑动到浏览器底部 time.sleep(2) # 等待加载 try: driver.find_element_by_css_selector('button.QuestionMainAction').click() # 点击更多按钮 print('Page' + str(n)) # 输出页码数 time.sleep(1) except: break execute_times(5000) # ************ 存储网页,⽤beautifulSoup把压缩后的 HTML ⽂件结构化并保存 ************ result_raw = driver.page_source # 原始网页 result_soup = BeautifulSoup(result_raw, 'html.parser') result_bf = result_soup.prettify() # 结构化原 HTML 文件 with open('./output/rawfile/raw_result.txt', 'w') as girls: girls.write(result_bf) girls.close() print('HTML数据存储成功!') # ************ 解码&lt;noscript&gt; html.parser.unescape ************ with open('./output/rawfile/noscript_meta.txt', 'w') as noscript_meta: noscript_nodes = result_soup.find_all('noscript') # 找到所有&lt;noscript&gt;node noscript_inner_all = '' for noscript in noscript_nodes: noscript_inner = noscript.get_text() # 获取&lt;noscript&gt; node内容 noscript_inner_all += noscript_inner + '\\n' noscript_all = html.parser.unescape(noscript_inner_all) # 将内容转码并存储 noscript_meta.write(noscript_all) noscript_meta.close() print('转码后&lt;noscript&gt;成功!') # ************************ 下载图片 **************************** img_soup = BeautifulSoup(noscript_all, 'html.parser') img_nodes = img_soup.find_all('img') with open(\"./output/rawfile/img_meta.txt\", 'w') as img_meta: count = 0 for img in img_nodes: if img.get('src') is not None: img_url = img.get('src') line = str(count) + \"\\t\" + img_url + \"\\n\" img_meta.write(line) urllib.request.urlretrieve(img_url, \"./output/image/output0/\" + str(count) + \".jpg\") # 一个一个下载图片 count += 1 img_meta.close() print(\"下载成功!\")if __name__ == '__main__': main()","link":"/2020/03/22/Python%E7%88%AC%E5%8F%96%E7%9F%A5%E4%B9%8E%E5%9B%BE%E7%89%87/"},{"title":"Python写入Excel数据(100万条,压力测试)","text":"​ 上周开发提测一个功能，某个导入业务需要支持100万条数据的量 ​ 于是就利用Python写了一些测试数据，100万测试数据占用空间差不多22MB。一个py文件，同级目录放2个表格，一个表格作为初始数据读取，另一个表格作为写入数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import xlrdimport xlsxwriterfileDemo = r'被读取的表格路径'insertData = r'数据写入的表格路径'data = xlrd.open_workbook(fileDemo)# 获取一个sheet页first_sheet = data.sheets()[0]# 获取表格数据content = first_sheet.row(3)\"\"\" content：[empty:'', empty:'', text:'91330108MA27XWH96M', text:'杭州西西沃', text:'万里测试真实企业', empty:'', empty:'', empty:'', empty:'', empty:'',empty:'', empty:'', empty:'', empty:'', empty:'', empty:'', empty:'', empty:'', empty:'', empty:''] 通过上面print内容可以看到，直接读出的内容，虽然是list，但每条数据前加了test字样，不能直接强转成tuple为我们所用， 于是自定义一个转换方法将其转换为可以用的list以便后面强转成tuple \"\"\"def rowToTuple(rowNum): data = [] for i in range(len(content)): data.append(first_sheet.cell_value(rowNum, i)) # 将每个单元格中的数据读取出来加到data这个list中并强转成元组返回 return tuple(data)# 将第0行（即excel中的第1行表头）数据读取并转成元组赋给headerheader = rowToTuple(2)# 将第1行（即excel中的第4行）示例数据读取并转成元组赋给data1data1 = rowToTuple(3)\"\"\" 如果数据量非常大，可以启用constant_memory，这是一种顺序写入模式，得到一行数据就立刻写入一行，而不会把所有的数据都保持在内存中。如果不启用此模式，当数据量巨大时，程序很大概率地卡死 \"\"\"workbook = xlsxwriter.Workbook(insertData, {'constant_menory': True})# 创建新的sheet页new_sheet = workbook.add_worksheet()# startNum表示从第几行开始写，这里的数字是从1开始，因为后面要和字母组合对应在excel中，如A1代表第1行第A列startNum = 1# 初始值，后面的数字在它们的基础上依次增加startValues = ['000000000000001','00000001']# 初始值对应的列col = ['C','D']#先将表头写入文件new_sheet.write_row('A' + str(startNum), header)# 正式开始写入数据for i in range(1000000): # 表头占据了第1行，所以首条数据从第2行开始，当i=0时，写入的数据从A2开始 print(\"正在生成第\",i+1, \"条数据...\") # 将data1中的数据依次写入C2、D2、…… new_sheet.write_row('A' + str(startNum + i + 1), data1) # 前面相当于复制了第一条数据的所有内容，但是C、D两列内容需要依次往下排，因此我们将重写每行中C、D单元格中的值 for m in col: length = len(startValues[col.index(m)]) # 数字用初始值+i content = str(int(startValues[col.index(m)]) + i) # 因为像000001这样的数字在计算中会丢失前面的0，为了保持位数，将失去的0再给它补回来 if (len(content) &lt; length): content = '0'* (length - len(content)) + content # 将计算好的值写入到对应的单元格中 new_sheet.write(m + str(startNum + i + 1), content)workbook.close()","link":"/2020/03/22/Python%E5%86%99%E5%85%A5Excel%E6%95%B0%E6%8D%AE-100%E4%B8%87%E6%9D%A1-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"},{"title":"golang 学习记录","text":"记录一下go语言的学习之路，持续更新~~ 一、 Go基础1、Hello World​ 第一章主要是go入门，只要是有其他语言基础或者计算机专业的这一章都是比较简单的，记录一下练习的代码 123456789package main// 导入语句import \"fmt\"// 程序入口func main() { fmt.Print(\"Hello World!\")} 2、常量与变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package main// 导入语句import \"fmt\"// 批量声明变量var ( name string age int sex bool)// 批量声明常量const ( n1 = 100 n2 n3)// iota 枚举const ( a1 = iota // 0 a2 // 1 a3 // 2)// 题目const ( b1 = iota //0 b2 //1 _ //2,丢弃的 b3 // 3)// 插队const ( c1 = iota //0 c2 = 100 //100 c3 = iota //0+1+1=2 c4 // 2+1=3)// 多个常量声明在一行 在一个const中每新增一行常量声明 iota+1const ( d1, d2 = iota + 1, iota + 2 //d1=0+1 d2=0+2 d3, d4 = iota + 1, iota + 2 //d3=1+1 d4=1+2)// 定义数量级const ( _ = iota //=0,丢弃 KB = 1 &lt;&lt; (10 * iota) MB = 1 &lt;&lt; (10 * iota) GB = 1 &lt;&lt; (10 * iota) TB = 1 &lt;&lt; (10 * iota) PB = 1 &lt;&lt; (10 * iota))// 程序入口func main() { //s输出变量 name = \"月满轩尼诗\" age = 18 sex = false fmt.Print(sex) fmt.Println(age) fmt.Printf(\"name:%s\", name) fmt.Println() fmt.Println(b1) fmt.Println(b2) fmt.Println(b3) fmt.Println(c1) fmt.Println(c2) fmt.Println(c3) fmt.Println(c4) fmt.Println(d1) fmt.Println(d2) fmt.Println(d3) fmt.Println(d4) fmt.Println(KB) fmt.Println(MB) fmt.Println(GB) fmt.Println(TB) fmt.Println(PB)} 3、整型1234567891011121314151617181920212223package mainimport \"fmt\"//整型func main() { // 十进制 var n1 = 101 fmt.Printf(\"%d\\n\", n1) fmt.Printf(\"%b\\n\", n1) //10进制-&gt;2进制 fmt.Printf(\"%o\\n\", n1) //10进制-&gt;8进制 fmt.Printf(\"%x\\n\", n1) //10进制-&gt;16进制 //八进制 n2 := 077 fmt.Printf(\"%d\\n\", n2) fmt.Printf(\"\") //十六进制 n3 := 0x1234567 fmt.Printf(\"%d\\n\", n3)} 4、浮点数1234567891011121314package mainimport \"fmt\"// 浮点数func main() { //math.MaxFloat32 //float32最大值 f1 := 1.234556789 fmt.Printf(\"%T\\n\", f1) // 默认go语言中的小数都是float64类型 f2 := float32(1.23456) fmt.Printf(\"%T\\n\", f2) //显示声明float32类型} 5、布尔型1234567891011package mainimport \"fmt\"// 布尔值func main() { b1 := true var b2 bool // 默认false fmt.Printf(\"%T\\n\", b1) fmt.Printf(\"%T value:%v\\n\", b2, b2)} 6、Fmt输出123456789101112131415161718192021222324252627282930313233343536373839package mainimport \"fmt\"// fmt占位符func main() { var n = 100 // 查看类型 /* fmt.Printf(\"%T\\n\", n) // 类型 fmt.Printf(\"%v\\n\", n) //值 fmt.Printf(\"%d\\n\", n) //十进制 fmt.Printf(\"%b\\n\", n) //二进制 fmt.Printf(\"%o\\n\", n) //八进制 fmt.Printf(\"%x\\n\", n) //十六进制 fmt.Printf(\"%c\\n\", n) //字符 fmt.Printf(\"%s\\n\", n) //字符串 fmt.Printf(\"%p\\n\", n) //指针 fmt.Printf(\"%v\\n\", n) //值 fmt.Printf(\"%f\\n\", n) //浮点数 s := \"golong学习第一天\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%v\\n\", s) fmt.Printf(\"%#v\\n\", s) */ percentage(n) // 整数-&gt;字符 fmt.Printf(\"%q\\n\", 97) // 字符串 fmt.Printf(\"%q\\n\", \"精绝古城\") // 浮点数和复数 fmt.Printf(\"%b\\n\", 3.14159263873124)}// 格式化输出百分比func percentage(x int) { fmt.Printf(\"%d%%\\n\", x)} 输出： 1234100%'a'\"精绝古城\"7074237718569953p-51 7、字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"fmt\" \"strings\")// 字符串 go语言字符串\"双引号包裹\"， 单引号是字符'你'、'g'func main() { // 单行字符串 s := \"/Users/Tony/go/src/github.io/2zyyyyy\" fmt.Printf(\"%#v\\n\", s) // 多行字符串 s2 := ` 世情薄 人情恶 雨送黄昏花易落 ` fmt.Println(s2) // 字符串相关操作 fmt.Println(len(s)) // 输出长度 //字符串拼接 name := \"测试\" world := \"test\" s3 := name + world // 通过+拼接 println(s3) s4 := fmt.Sprintf(\"%s%s\", name, world) // sprint 返回字符串变量 fmt.Println(s4) // 分隔字符串 ret := strings.Split(s, \"/\") fmt.Println(ret) // 字符串包含 fmt.Println(strings.Contains(s4, \"测试\")) // 前缀 fmt.Println(strings.HasPrefix(s4, \"测试\")) // 返回true // 后缀 fmt.Println(strings.HasSuffix(s4, \"测试\")) // 返回false // 输出字符串出现的位置 sss := \"abc测试字符串@@@c\" fmt.Println(len(sss)) fmt.Println(strings.Index(sss, \"测试\")) fmt.Println(strings.LastIndex(sss, \"c\")) // 拼接 fmt.Println(strings.Join(ret, \"*\"))} 8、Byte&amp;&amp;Rune123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"fmt\" \"strconv\" \"unicode\")// byte 和 rune 类型// go语言为了处理非ASCII码类型的字符 定义了新的rune类型func main() { s := \"月满轩尼诗\" // len() 求得是byte字节的数量 n := len(s) fmt.Println(n) /* for i := 0; i &lt; len(s); i++ { fmt.Println(s[i]) fmt.Printf(\"%c\\n\", s[i]) // %c 字符 } */ for _, c := range s { // 从字符串中拿出具体的字符 fmt.Printf(\"%c\\n\", c) // %c: 字符 } // 字符串修改 原则上不能修改 需要转换成其他变量 s2 := \"我是被修改的字符串\" s3 := []rune(s2) // 把字符串强制转换成rune切片 s3[0] = '你' // s2是字符串 单独修改第一个需要是字符 故 '你' 单引号包裹 fmt.Println(string(s3)) a1 := \"绿\" // string a2 := '绿' //rune(int32) fmt.Printf(\"a1:%T a2:%T\\n\", a1, a2) // 类型转换 n1 := 10 var f float64 f = float64(n1) fmt.Println(f) fmt.Printf(\"%T\\n\", f) // 练习：统计一个字符串中汉字的数量 str := \"1234我是汉字I'm man!@#$%^&amp;*()_+\" var count int for _, v := range str { if unicode.Is(unicode.Han, v) { count++ } } fmt.Println(\"当前字符串\" + str + \"\\n\" + \"共有：\" + strconv.Itoa(count) + \"个中文汉字\")} 9、If条件判断12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"// if条件判断func main() { age := 18 if age &gt;= 18 { fmt.Println(\"大于18，条件1通过！\") } else { fmt.Println(\"小于18，条件1未通过，通过条件2\") } // 多个条件 score := 75 if score &gt;= 90 { fmt.Println(\"优秀！！！\") } else if score &gt;= 75 { fmt.Println(\"良好~~\") } else if score &gt;= 60 { fmt.Println(\"及格...\") } else { fmt.Println(\"不及格???\") } // 特殊写法 作用域 if num := 9; num &gt;= 0 { // num 局部变量 fmt.Println(\"大于等于9\") } else { fmt.Println(\"小于等于9\") } // fmt.Println(num) num无法找到 这样写节省内存占用} 10、for循环123456789101112131415161718192021222324252627282930313233343536package mainimport \"fmt\"// for 循环func main() { // 基本格式 for i := 0; i &lt;= 10; i++ { fmt.Println(i) } // 套路1 省略初始语句 var i = 0 for ; i &lt;= 3; i++ { fmt.Println(i) } // 套路2 省略结束语句 var n = 5 for n &lt; 10 { fmt.Println(n) n++ } // 无限循环 for { fmt.Println(\"无限循环\") } // for range循环 s := \"Hi月满轩尼诗\" for i, v := range s { fmt.Printf(\"%d %c\\n\", i, v) } // 哑元变量 不想用到的都直接丢给他 s := \"月满轩尼诗\" for _, v := range s { fmt.Printf(\"%c\\n\", v) } 11、Switch123456789101112131415161718192021222324252627282930313233package mainimport \"fmt\"// switch 简化大量判断func main() { // var n = 3 switch n := 3; n { case 1: fmt.Println(\"大拇指\") case 2: fmt.Println(\"食指\") case 3: fmt.Println(\"中指\") case 4: fmt.Println(\"无名指\") case 5: fmt.Println(\"小拇指\") default: fmt.Println(\"异常输入~\") } // 判断奇偶数 switch n := 7; n { case 1, 3, 5, 7: fmt.Println(\"他们是奇数~~\") case 2, 4, 6, 8: fmt.Println(\"他们是偶数~！\") default: fmt.Println(\"猜猜我是谁？\") }} 12、goto1234567891011121314151617181920212223242526272829303132333435363738package mainimport \"fmt\"// gotofunc main() { // 常规操作，跳出多层for循环 var flag = false for i := 0; i &lt; 10; i++ { for j := 'A'; j &lt; 'Z'; j++ { fmt.Println(\"标记flag=true，跳出内循环~~\") flag = true break // 跳出内层循环 } if flag { fmt.Println(\"外层循环发现flag==true, 跳出外层循环！！\") break // 跳出外层循环 } } // 骚操作 goto for i := 0; i &lt; 10; i++ { for j := 0; j &lt; 10; j++ { if j == 2 { // 设置退出标签 fmt.Println(\"跳到当前指定标签：breakTag~~~\") goto breakTag } fmt.Printf(\"%v-%v\\n\", i, j) } } return // 标签breakTag: fmt.Println(\"结束for循环\")} 13、运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package mainimport \"fmt\"// 运算符func main() { var ( a = 5 b = 2 ) // 算术运算符：加减乘除 余数 fmt.Println(\"a+b=\", a+b) fmt.Println(\"a-b=\", a-b) fmt.Println(\"a*b=\", a*b) fmt.Println(\"a/b=\", a/b) fmt.Println(\"a'%'b=\", a%b) // 自增/自减 a++ b-- // 关系运算符 fmt.Println(a == b) // golang 是强类型语言 相同类型的变量才能比较 fmt.Println(a != b) // 不等于 fmt.Println(a &gt; b) //大于 fmt.Println(a &gt;= b) //大小于等于 fmt.Println(a &lt; b) // 小于 fmt.Println(a &lt;= b) // 小于 // 逻辑运算符 // 如果分数大于60分而且小于100分 score := 75 if score &gt; 60 &amp;&amp; score &lt; 100 { fmt.Println(\"好好学习~\") } else { fmt.Println(\"不用学习...\") } // 如果年龄小于18岁或者年龄大于60岁 age := 26 if age &gt; 60 || age &lt; 18 { fmt.Println(\"国家帮养老~~~\") } else { fmt.Println(\"打工仔...\") } // not 取反 isMarried := false fmt.Println(isMarried) // false fmt.Println(!isMarried) // true // 位运算符：针对二进制数 // 5 = 101 2 = 010 （二进制） // &amp;:a按位与 fmt.Println(5 &amp; 2) // 全1为1 000 // |：按位或 fmt.Println(5 | 2) /// 有1为1 111 // ^:按位异或（不一样则为1） fmt.Println(5 ^ 2) // &lt;&lt;:将二进制位往左指定位数 5-&gt;00000101 00010100 fmt.Println(5 &lt;&lt; 2) // &gt;&gt;:将二进制位往右指定位数 5-&gt;00000101 00000001 fmt.Println(5 &gt;&gt; 2) // 赋值运算符 给变量赋值 var x = 10 x++ // x = x +1 x-- // x = x -1 x *= 2 // x = x * 2 x /= 2 // x = x / 2 x %= 2 // x = x % 2 x &lt;&lt;= 2 // x = x &lt;&lt; 2 左移 x &amp;= 2 // x = x &amp; 2 位与 x |= 2 // x = x | 2 位或 x ^= 4 // x = x | 2 异或 x &gt;&gt;= 2 // x = x &lt;&lt; 2 右移} 14、复合数据类型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package mainimport \"fmt\"// 复合数据类型/*数组定义：var 数组变量名 [元素数量]T (类型)存放元素的容器必须制定存放元素的类型和长度golang：数组的长度是数组类型的一部分*/func main() { var list1 [5]int var list2 [10]int fmt.Printf(\"list1:%T list2:%T\\n\", list1, list2) // 数组的初始化 不初始化默认是0 int: 0 string:“” bool:false fmt.Println(list1, list2) // 1、初始化方式01 创建变量的时候赋值 list1 = [5]int{0, 1, 2, 3, 4} fmt.Println(list1) // 2、初始化方式02 根据初始值自动腿短数组的长度是多少 list100 := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} fmt.Printf(\"%T\\n\", list100) // 3、初始化方式03 根据索引初始化 list3 := [5]int{0: 1, 4: 2} fmt.Println(list3) // 数组的遍历 city := [...]string{\"杭州\", \"宁波\", \"金华\"} // 1、根据索引 for i := 0; i &lt; len(city); i++ { fmt.Println(city[i]) } // 2、for range 遍历 for i, v := range city { fmt.Println(i, v) } // 多维数组 // [[1 2] [3 4] [5 6]] var all [3][2]int all = [3][2]int{ [2]int{1, 2}, [2]int{3, 4}, [2]int{5, 6}, } fmt.Println(all) // 多维数组的遍历 for _, v1 := range all { fmt.Println(v1) for _, v2 := range v1 { fmt.Println(v2) } } // 数组是值类型 b1 := [3]int{1, 2, 3} b2 := b1 b2[0] = 100 fmt.Println(b1, b2) // 练习题1 求数组[1,3,5,7,8]元素的和 c1 := [...]int{1, 3, 5, 7, 8} sum := 0 for _, v := range c1 { sum = sum + v } fmt.Println(sum) /* 找出数组中和位置性质的两个元素的下标，比如[1, 3, 5, 7, 8]中找出和为8两个元素的下标分别为(0,3)(1,2) 定义2个for循环 外层从第n个开始遍历 内层for循环从n+1开始找 1和2的和为8 */ for i := 0; i &lt; len(c1); i++ { for j := i + 1; j &lt; len(c1); j++ { if c1[i]+c1[j] == 8 { fmt.Printf(\"(%d, %d)\\n\", i, j) } } }} 15、slice（切片）12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport \"fmt\"/* 切片:是一个拥有相同类型元素的可变长度的序列他是基于数组类型做的一层封装，他非常灵活，支持自动扩容切片是一个引用类型，他的内部结构包含地址、长度和容量。切片一般用户快速的操作一块数据集合 */func main() { var s1 []int //定义一个存放int类型元素的切片 var s2 []string fmt.Println(s1, s2) fmt.Println(s1 == nil) fmt.Println(s2 == nil) // 初始化 s1 = []int{1, 2, 3} s2 = []string{\"杭州\", \"金华\", \"苏州\", \"嘉兴\"} fmt.Println(s1, s2) fmt.Println(s1 == nil) fmt.Println(s2 == nil) // 长度和容量 fmt.Printf(\"len(s1)= %d cap(s1)= %d\\n\", len(s1), cap(s1)) fmt.Printf(\"len(s2)= %d cap(s2)= %d\\n\", len(s2), cap(s2)) // 由数组获得切片 a1 := [...]int{1, 3, 5, 7, 9, 11, 13} s3 := a1[0:4] // 基于数组切割，[) 左包含右不包含 fmt.Println(\"s3=\", s3) s5 := a1[:4] // [0:4] s6 := a1[3:] // [3:len(a1)] s7 := a1[:] // [0:len(a1)] fmt.Println(s5, s6, s7) // s5 的长度和容量(容量是指底层数组的容量 这里也就是a1的容量) fmt.Printf(\"len(s5): %d cap(s5): %d\\n\", len(s5), cap(s5)) // s6 从中间开始切，所以下标前面的容量不计算在s6容量里面 fmt.Printf(\"len(s6): %d cap(s6): %d\\n\", len(s6), cap(s6)) //切片再切割 fmt.Println(\"s6=:\", s6) s8 := s6[3:] fmt.Printf(\"len(s8): %d cap(s8): %d\\n\", len(s8), cap(s8))} 16、make创建切片12345678910111213141516171819202122232425262728293031323334package mainimport \"fmt\"// make函数创建切片/*切片的本质切片就是一个框，框住了一块连续的内存切片属于引用类型，真正的数据都是保存在底层数组的*/func main() { s1 := make([]int, 5, 10) fmt.Printf(\"s1=%v len(s1):=%d cap(s1):=%d\\n\", s1, len(s1), cap(s1)) s2 := make([]int, 0, 10) fmt.Printf(\"s2=%v len(s2):=%d cap(s2):=%d\\n\", s2, len(s2), cap(s2)) // 切片的赋值 s3 := []int{1, 3, 5} s4 := s3 // s3 s4都指向了同一个底层数组 fmt.Println(s4) s3[0] = 1000 fmt.Println(s4) // 切片的遍历 // 1、索引遍历 for i := 0; i &lt; len(s3); i++ { fmt.Println(s3[i]) } // 2、for range 遍历 for i, v := range s3 { fmt.Println(i, v) }} 17、slice append12345678910111213141516171819package main// 切片的append()import \"fmt\"func main() { s1 := []string{\"杭州\", \"嘉兴\", \"金华\"} fmt.Printf(\"s1=%v len(s1)=%d cap(s1)=%d\\n\", s1, len(s1), cap(s1)) // 调用append()函数必须使用原来的切片变量接收返回值 // 必须用变量接收append返回值 s1 = append(s1, \"宁波\") // append追加元素，原来的底层数组放不下的时候 go底层就会把底层数组换一个 fmt.Printf(\"s1=%v len(s1)=%d cap(s1)=%d\\n\", s1, len(s1), cap(s1)) // 自动扩容 s2 := []string{\"武汉\", \"成都\", \"苏州\"} s1 = append(s1, s2...) // s2为切片类型无法直接赋值给s1 需要用...表示拆开 fmt.Printf(\"s1=%v len(s1)=%d cap(s1)=%d\\n\", s1, len(s1), cap(s1))} 18、slice copy12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"sort\")// slice copy()func main() { a1 := []int{1, 3, 5} a2 := a1 // 赋值 // var a3 []int nil var a3 = make([]int, 3, 3) copy(a3, a1) // copy fmt.Println(a1, a2, a3) a1[0] = 10000 fmt.Println(a1, a2, a3) // 切片中删除元素 // 将a1索引为1的元素（3）删除 a1 = append(a1[:1], a1[2:]...) fmt.Println(a1) // 切片练习题 // 1、写出输出值 var a = make([]int, 5, 10) for i := 0; i &lt; 10; i++ { a = append(a, i) } fmt.Println(a) // 2、使用sort包对数组var a = [...]int{3,7,9,8,1}排序 var l1 = [...]int{3, 7, 8, 9, 1} sort.Ints(l1[:]) // 对切片进行排序 fmt.Println(l1)} 19、pointer 指针1234567891011121314151617181920212223242526272829package mainimport \"fmt\"// golang 指针(pointer)func main() { // 1、'&amp;':取地址 // 2、'':根据地址取值 n := 10 fmt.Println(&amp;n) // 根据值取内存地址 address := &amp;n fmt.Printf(\"%T\\n\", address) m := *address fmt.Println(m) // 根据内存地址取值 // var a *int nil pointer var a = new(int) fmt.Println(a) *a = 100 fmt.Println(*a) /* make和new的区别 1、make和new都是用来申请内存的 2、new很少用，一般用来给基本数据类型申请内存，string/int ...，返回的是对应类型的指针(*string、*int) 3、make是用来给slice、map、chan 申请内存的，make函数返回的是对应的这三个类型本身 */} 20、map1234567891011121314151617181920212223242526272829303132333435363738394041package mainimport \"fmt\"// mapfunc main() { var mp map[string]int fmt.Println(mp == nil) // 没有初始化(未在内存中开辟空间) // make初始化map 估算好map容量，避免动态扩容 mp = make(map[string]int, 10) mp[\"测试\"] = 100 mp[\"test\"] = 99 mp[\"dev\"] = 120 fmt.Println(mp) // 获取value fmt.Println(mp[\"test\"]) // 如果接收的key不存在 value, ok := mp[\"不存在的key\"] if !ok { fmt.Println(\"查无此key~~~\") } else { fmt.Println(value) } // map的遍历 for k, v := range mp { fmt.Println(k, v) } // 遍历key for k := range mp { fmt.Println(k) } // 遍历value for _, v := range mp { fmt.Println(v) } // 删除 delete(mp, \"111\") fmt.Println(mp)} 21、map与slice组合12345678910111213141516171819202122232425262728293031323334package mainimport ( \"fmt\" \"strings\")// map与slice组合func main() { // 元素为map类型的切片 var s1 = make([]map[int]string, 10, 10) // make初始化切片 // 初始化map s1[0] = make(map[int]string, 1) s1[0][9999] = \"系统异常，请稍后重试！\" fmt.Println(s1) // 值为切片类型的map var m1 = make(map[string][]int, 10) m1[\"杭州\"] = []int{1, 2, 3} // m1[\"杭州\"] = make([]int, {1,2,3}) fmt.Println(m1) // 统计一个字符串中每个单词出现的次数 s3 := \"what do you do what ?\" //定义切片并初始化 count := make(map[string]int) // 切割字符串 s4 := strings.Split(s3, \" \") for _, v := range s4 { count[v]++ } fmt.Println(count)} 22、func 函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport \"fmt\"/* golang 函数函数是一段代码的封装把一段逻辑抽象出来封装到一个函数，定义函数名称，每次使用调用该函数即可使用函数可以使代码更加清晰、简洁 */// 函数的定义func sum(x int, y int) (ret int) { ret = x + y return // 使用命名返回值可以直接return}// 无返回值func f1(x int, y int) { fmt.Println(x + y)}// 无参无返回func f2() { fmt.Println(\"f2\")}// 无参有返回值func f3() int { return 3}func f4() (int, string) { return 1, \"golang~~~\"}// 参数的类型简写func f5(x, y int) int { return x + y}// 可变长参数func f6(x string, y ...int) { // 可变长参数必须放在参数最后 fmt.Println(x) fmt.Println(y) // y的类型是slice 切片[]int}func main() { var s = sum(10, 20) fmt.Println(s) _, n := f4() fmt.Println(n) f6(\"python\") f6(\"python\", 1, 2, 3, 4, 5)} 23、defer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport \"fmt\"// 多用于函数结束之前结束资源文件、数据库、socket连接func deferDemo() { fmt.Println(\"start!\") // defer 把他后面的语句延迟执行，直到函数即将返回的时候 // 多个defer，后进先出（先进后出） 003 -&gt; 002 -&gt; 001 defer fmt.Println(\"defer 001 !!!\") defer fmt.Println(\"defer 002 !!!\") defer fmt.Println(\"defer 003 !!!\") fmt.Println(\"end\")}func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret}func main() { // deferDemo() a := 1 b := 2 defer calc(\"1\", a, calc(\"10\", a, b)) a = 0 defer calc(\"2\", a, calc(\"20\", a, b)) b = 1}/* main分析a = 1 b = 21.defer calc(\"1\", 1, calc(\"10\", 1, b))2.calc(\"10\", 1, 2) --&gt; \"10\" 1 2 33.defer calc(\"1\", 1, 3)4.a = 05.defer calc(\"2\", 0, calc(\"20\", 0, 2))6.calc(\"20\", 0, 2) --&gt; \"20\" 0 2 27.defer calc(\"2\", 0, 2)8.b = 1 b此时用不到 混淆作用9.calc(\"2\", 0, 2) --&gt; \"2\" 0 2 210.calc(\"1\", 1, 3) --&gt; \"1\" 1 3 4输出：\"10\" 1 2 3\"20\" 0 2 2\"2\" 0 2 2\"1\" 1 3 4 */ 24、defer return1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport \"fmt\"// golang 函数中的return不是原子操作，底层分为2步执行// 1、返回值赋值 2、真正ret返回// 如果函数中存在defer，那么defer执行的时机是第一步和第二步之间func f1() int { x := 5 defer func() { x++ // 返回5，修改的是x,而不是返回值 }() return x}func f2() (x int) { defer func() { x++ }() return 5 // 返回x=6}func f3() (y int) { x := 5 defer func() { x++ // 修改的是x的值，不影响之前的x赋值给y=5 }() return x // 返回:y = x = 5}func f4() (x int) { defer func(x int) { x++ // 改变的是函数中的副本 }(x) return 5 // 返回值=x=5}func main() { fmt.Println(f1()) fmt.Println(f2()) fmt.Println(f3()) fmt.Println(f4())} 25、func type12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport \"fmt\"// 函数类型func f1() { fmt.Println(\"golang!!!\")}func f2() int { return 10}// 函数作为参数func f3(x func() int) { ret := x() fmt.Println(ret)}func f4(x, y int) int { return x + y}// 函数作为返回值func f5(x func() int) func(int, int) int { ret := func(a, b int) int { sum := a + b return sum } return ret}func main() { a := f1 fmt.Printf(\"%T\\n\", a) b := f2 fmt.Printf(\"%T\\n\", b) // fmt.Printf(\"%T\\n%T\\n\", f3, f4) f7 := f5(f2) fmt.Printf(\"%T\\n\", f7)} 26、匿名函数123456789101112131415161718package mainimport \"fmt\"// 匿名函数func main() { // 用变量接收匿名函数 var f1 = func(x, y int) { fmt.Println(x + y) } f1(1, 99) // 如果函数只执调用一次，可以简写成立即执行函数(加一个括号，如有参数括号内传参） func(a, b int) { fmt.Println(\"匿名函数立即调用:\", a+b) }(1, 19)} 27、闭包27.1、 demo 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport \"fmt\"/* 闭包概念：闭包 = 函数 + 外部变量的引用底层原理：1、函数可以作为返回值2、函数内部查找变量的顺序，现在自己内部找，找不到往外找*/// 闭包01func adder(x int) func(int) int { return func(y int) int { x += y return x }}// 闭包02 要求f1(f2) 曲线救国func f1(f func()) { // 函数做参数 fmt.Println(\"this func is f1~~\") f()}func f2(x, y int) { fmt.Println(\"this func is f2~~~\\n闭包02：\", x+y)}// 定义函数f3对函数f2包装func f3(f func(int, int), x, y int) func() { tmp := func() { // fmt.Println(x) // 现在自己里面找x，在往上找（test函数） f(x, y) // f(x,y) 是f3的三个参数（f()、x、y） } return tmp}func main() { /* a1 := adder(100) a2 := a1(50) fmt.Println(\"闭包01：\", a2) */ ret := f3(f2, 1, 999) // 把原来需要传递2个int类型的参数包装秤一个不需要传参的函数 // ret() f1(ret) // f1(f3(f2, 1, 99))} 27.2、 demo 228、Scan1234567891011121314151617181920package mainimport \"fmt\"// Scan 获取用户输入func main() { /* var s string fmt.Scan(&amp;s) fmt.Println(\"用户输入的内容是：\", s) */ var ( name, class string age int ) /* fmt.Scanf(\"%s %d %s\\n\", &amp;name, &amp;age, &amp;class) fmt.Println(\"学生信息为：\", name, age, class) */ fmt.Scanln(&amp;name, &amp;age, &amp;class) fmt.Println(\"学生信息为：\", name, age, class)} 练习题1、输出字符串中的汉字数量123456789// 练习：统计一个字符串中汉字的数量 str := \"1234我是汉字I'm man!@#$%^&amp;*()_+\" var count int for _, v := range str { if unicode.Is(unicode.Han, v) { count++ } } fmt.Println(\"当前字符串\" + str + \"\\n\" + \"共有：\" + strconv.Itoa(count) + \"个中文汉字\") 2、for循环打印99乘法表1234567/ 练习打印九九乘法表 for i := 1; i &lt; 10; i++ { for j := 1; j &lt;= i; j++ { fmt.Printf(\"%dx%d=%d\\t\", j, i, i*j) } fmt.Println(\"\") } 输出： 12当前字符串：1234我是汉字I'm man!@#$%^&amp;*()_+共有：4个中文汉字 输出： 1234567891x1=11x2=2 2x2=41x3=3 2x3=6 3x3=91x4=4 2x4=8 3x4=12 4x4=161x5=5 2x5=10 3x5=15 4x5=20 5x5=251x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=361x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=491x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=641x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81 3、求数组[1,3,5,7,8]元素的和123456c1 := [...]int{1, 3, 5, 7, 8} sum := 0 for _, v := range c1 { sum = sum + v } fmt.Println(sum) 4、找出数组中和位置性质的两个元素的下标​ 比如[1, 3, 5, 7, 8]中找出和为8两个元素的下标分别为(0,3)(1,2) 1234567for i := 0; i &lt; len(c1); i++ { for j := i + 1; j &lt; len(c1); j++ { if c1[i]+c1[j] == 8 { fmt.Printf(\"(%d, %d)\\n\", i, j) } } } 5、统计一个字符串中每个单词出现的次数123456789s3 := \"what do you do what ?\"//定义切片并初始化count := make(map[string]int)// 切割字符串s4 := strings.Split(s3, \" \")for _, v := range s4 { count[v]++}fmt.Println(count) 输出： 1map[?:1 do:2 what:2 you:1] 6、分金币1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport \"fmt\"/* 练习题：分金币你有五十枚金币，需要分给以下几个人：1.Matthew 2.Sarah 3.Augustus 4.Heidi 5.Emilie 6.Peter 7.Giana 8.Adriano 9.Aaron 10.Elizabeth分配规则如下：a.名字中每包含一个'e'或'E'分1枚金币b.名字中每包含一个'i'或'I'分2枚金币c.名字中每包含一个'o'或'O'分2枚金币d.名字中每包含一个'u'或'U'分2枚金币用golang编写程序，计算每个用户分到多少枚金币，以及最后剩余多少金币？程序结构如下，请实现'dispatchCoin' */var ( coins = 50 users = []string{ \"Matthew\", \"Sarah\", \"Augustus\", \"Heidi\", \"Emilie\", \"Peter\", \"Giana\", \"Adriano\", \"Aaron\", \"Elizabeth\", } distribution = make(map[string]int, len(users)))func dispatchCoin() (left int) { /* 思路： 1.依次拿到每个人的名字，遍历users 2.获取到一个名字根据规则分配金币 2.1.没人分得金币数应该保存到distribution中 2.2.计算剩余金币数量 */ for _, name := range users { for _, c := range name { switch c { case 'e', 'E': // 满足该条件给给用户分配金币 distribution[name]++ coins-- case 'i', 'I': distribution[name] += 2 coins -= 2 case 'o', 'O': distribution[name] += 3 coins -= 3 case 'u', 'U': distribution[name] += 4 coins -= 4 } } } left = coins return}func main() { left := dispatchCoin() // 第二种计算剩余金币方法 计算出map中所有value的和 然后 用金币总数减去 count := 0 for n := range distribution { count += distribution[n] } fmt.Println(count) fmt.Println(\"剩下：\", left, (50 - count)) for k, v := range distribution { fmt.Printf(\"%s:%d\\n\", k, v) }} 输出： 123456789101140剩下： 10 10Matthew:1Augustus:12Heidi:5Emilie:6Peter:2Giana:2Adriano:5Aaron:3Elizabeth:4","link":"/2020/03/01/Golang-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"Golang 分金币题目解析","text":"1、分金币1.1、要求​ 你有五十枚金币，需要分给以下几个人： 1.Matthew 2.Sarah 3.Augustus 4.Heidi 5.Emilie 6.Peter 7.Giana 8.Adriano 9.Aaron 10.Elizabeth分配规则如下：a.名字中每包含一个’e’或’E’分1枚金币b.名字中每包含一个’i’或’I’分2枚金币c.名字中每包含一个’o’或’O’分2枚金币d.名字中每包含一个’u’或’U’分2枚金币 1.2、 结果​ 用golang编写程序，计算每个用户分到多少枚金币，以及最后剩余多少金币？ 1.3分析、首先我们对这个题目进行一个步骤解析： 确定需要的变量： coins：金币数量 users：需要分金币的用户名 distribution：每个用户以及分得的金币数量以Key:Value格式存放在Map中 1.依次拿到每个人的名字，遍历users2.获取到一个名字根据规则分配金币 2.1.没人分得金币数应该保存到distribution中 2.2.计算剩余金币数量 2、实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport &quot;fmt&quot;var ( coins = 50 users = []string{ &quot;Matthew&quot;, &quot;Sarah&quot;, &quot;Augustus&quot;, &quot;Heidi&quot;, &quot;Emilie&quot;, &quot;Peter&quot;, &quot;Giana&quot;, &quot;Adriano&quot;, &quot;Aaron&quot;, &quot;Elizabeth&quot;, } distribution = make(map[string]int, len(users)))func dispatchCoin() (left int) { /* 思路： 1.依次拿到每个人的名字，遍历users 2.获取到一个名字根据规则分配金币 2.1.没人分得金币数应该保存到distribution中 2.2.计算剩余金币数量 */ for _, name := range users { for _, c := range name { switch c { case 'e', 'E': // 满足该条件给给用户分配金币 distribution[name]++ coins-- case 'i', 'I': distribution[name] += 2 coins -= 2 case 'o', 'O': distribution[name] += 3 coins -= 3 case 'u', 'U': distribution[name] += 4 coins -= 4 } } } left = coins return}func main() { left := dispatchCoin() // 第二种计算剩余金币方法 计算出map中所有value的和 然后 用金币总数减去 count := 0 for n := range distribution { count += distribution[n] } fmt.Println(count) fmt.Println(&quot;剩下：&quot;, left, (50 - count)) for k, v := range distribution { fmt.Printf(&quot;%s:%d\\n&quot;, k, v) }} 3、输出","link":"/2020/04/19/Golang-%E5%88%86%E9%87%91%E5%B8%81%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"}],"tags":[{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"hexo博客","slug":"hexo博客","link":"/tags/hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Allure2","slug":"Allure2","link":"/tags/Allure2/"},{"name":"Pytest","slug":"Pytest","link":"/tags/Pytest/"},{"name":"测试报告","slug":"测试报告","link":"/tags/%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"},{"name":"移动开发","slug":"移动开发","link":"/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"安卓","slug":"安卓","link":"/tags/%E5%AE%89%E5%8D%93/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"CI/CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"可持续集成","slug":"可持续集成","link":"/tags/%E5%8F%AF%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"ECS","slug":"ECS","link":"/tags/ECS/"},{"name":"阿里云服务器","slug":"阿里云服务器","link":"/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"数据","slug":"数据","link":"/tags/%E6%95%B0%E6%8D%AE/"},{"name":"大数据测试","slug":"大数据测试","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Smtplib","slug":"Smtplib","link":"/tags/Smtplib/"},{"name":"Email","slug":"Email","link":"/tags/Email/"},{"name":"golang","slug":"golang","link":"/tags/golang/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Excel","slug":"Excel","link":"/tags/Excel/"}],"categories":[{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Pytest","slug":"Pytest","link":"/categories/Pytest/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Jenkins","slug":"Jenkins","link":"/categories/Jenkins/"},{"name":"阿里云ECS","slug":"阿里云ECS","link":"/categories/%E9%98%BF%E9%87%8C%E4%BA%91ECS/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"golang","slug":"golang","link":"/categories/golang/"},{"name":"go","slug":"golang/go","link":"/categories/golang/go/"},{"name":"MySQL","slug":"Python/MySQL","link":"/categories/Python/MySQL/"},{"name":"爬虫","slug":"Python/爬虫","link":"/categories/Python/%E7%88%AC%E8%99%AB/"}]}